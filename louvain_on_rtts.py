import os
import sys

import pandas as pd
import numpy as np

import networkx as nx
import community.community_louvain as community_louvain

def to_int(l):
    """
    This function transforms the column of rtts ids back to int 
    (due to pandas .csv format lists are transformed in str)
    """
    L = l.replace(' ', '').replace('[', '').replace(']', '').split(',')
    return [int(x) for x in L]

def build_rtt_graph(df):
    """
    Builds the graph with an edge representing a rtt and each edge
    having the sentiment as weight.

    Parameters
    ----------
        df : pandas.DataFrame

    Returns
    -------
        G : networkx.graph
            the built graph
    """
    tweet_authors = np.unique(df['author_id'].to_numpy(dtype = 'int64'))
    retweet_authors = np.unique(np.concatenate(df['rtt_author_ids'].to_numpy()))

    G = nx.Graph()

    ## ADDING NODES
    # adding authors that tweeted, with their screen names
    for i in range(len(tweet_authors)):
        sn = df[df['author_id'] == tweet_authors[i]]['screen_name'].iloc[0]
        G.add_node(tweet_authors[i], screen_name = sn)

    # adding retweeting authors with empty string as screen name
    for a in retweet_authors:
        if a not in tweet_authors:
            G.add_node(a, screen_name = '')

    ## ADDING EDGES
    # creating edges with sentiment as weight
    L1 = np.array(df['author_id'])
    L2 = np.array(df['rtt_author_ids'])
    L3 = np.array(np.abs(df['sentiment']))

    for i in range(len(L1)):
        for a in L2[i]:
            G.add_edge(L1[i], a, weight = L3[i])

    return G

def remove_not_connected(G):
    """
    only keeps the largest connected component of the graph and returns a copy of it

    Parameters
    ----------
        G : networkx.Graph
            the graph

    returns
    -------
        G : networkx.Graph
            the filtered graph
    """
    num_connected_components = nx.number_connected_components(G)
    connected_components = nx.connected_components(G)

    l = []
    for i in nx.connected_components(G):
        l.append(len(i))
    l.sort(reverse = True)
    
    print(r"""There are {} connected components. The largest has {} nodes and the second {}""". format(num_connected_components, l[0], l[1]))
    max_cc = max(connected_components, key = len)

    return G.subgraph(max_cc).copy()

def generate_subgraphs(G):
    """
    Generates the Louvain partitions of the given graph.

    Parameters
    ----------
        G : networkx.Graph
            the graph

    Returns
    -------
        subgraphs : list of networkx.Graph
            the list of all partitions generated by the Louvain algorithm
    """
    partitions = community_louvain.best_partition(G)
    num_partitions = len(np.unique(list(partitions.values())))
    print(r"""Number of partition from Louvain: {}""".format(num_partitions))

    sets = []

    for i in range(num_partitions):
        sets.append(set())

    for k,v in partitions.items():
        sets[v].add(k)

    subgraphs = [G.subgraph(s).copy() for s in sets]
    return subgraphs

def save_graphs(graphs, path = 'graphs', threshold = 20):
    """
    Saves the graphs in a folder given by the path. The files are of the form Gx_y.gexf,
    where x is the graph number and y the number of elements in the graphs.

    warning: it empties the folder given by the path argument if not empty

    Parameters
    ----------
        graphs : list of networkx.Graph
            the graphs to save

        path : str
            The folder in which to store the graphs

        threshold : int
            minimal number a subgraph needs to have to be kept

    """
    if not os.path.exists(path):
        os.mkdir(path)
    else:
        for f in os.listdir(path):
            os.remove(os.path.join(path, f))

    for (i, subgraph) in enumerate(graphs):
        N = len(subgraph)
        if(N > threshold):
            nx.write_gexf(subgraphs[i], os.path.join('graphs', 'G{}_{}.gexf'.format(i, N)))

if __name__ == '__main__':

    assert(len(sys.argv) == 2)

    file_name = sys.argv[1]

    df = pd.read_csv(file_name)

    df['rtt_author_ids'] = df['rtt_author_ids'].map(to_int)

    G = build_rtt_graph(df)
    G = remove_not_connected(G)
    
    subgraphs = generate_subgraphs(G)

    save_graphs(subgraphs)
